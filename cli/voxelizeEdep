#!/usr/bin/env python3

from larndsim import voxelize as vox

from LarpixParser import hit_parser as HitParser
from LarpixParser import event_parser as EvtParser
from LarpixParser.geom_to_dict import larpix_layout_to_dict
from LarpixParser import util

import h5py
import numpy as np
import tqdm
from collections import defaultdict

# a bit wider than the generation volume
xMin, xMax, xWidth = 410.0, 920.0, 0.38
yMin, yMax, yWidth = -225.0, 85.0, 0.38
zMin, zMax, zWidth = -305.0, 405.0, 0.38

nVoxX = int((xMax - xMin)/xWidth)
nVoxY = int((yMax - yMin)/yWidth)
nVoxZ = int((zMax - zMin)/zWidth)

minVox = np.array([xMin, yMin, zMin])
maxVox = np.array([xMax, yMax, zMax])

spacing = np.array([xWidth, yWidth, zWidth])

trackVoxelEdges = (np.linspace(xMin, xMax, nVoxX + 1),
                   np.linspace(yMin, yMax, nVoxY + 1),
                   np.linspace(zMin, zMax, nVoxZ + 1))

def voxelize(tracks):
    sampleDensity = 100000 # samples per unit (mm) length

    # print ('voxelizing tracks')
    # for track in tqdm.tqdm(tracks):
    for track in tracks:
        start = np.array([track['x_start'],
                          track['y_start'],
                          track['z_start']])
        end = np.array([track['x_end'],
                        track['y_end'],
                        track['z_end']])

        nSamples = int(track['dx']*sampleDensity)

        trackSampleSpace = np.expand_dims(np.linspace(0, 1, nSamples), -1)
        # sample with a fixed spacing along the track trajectory
        trackSamplePoints = start + trackSampleSpace*(end - start)
        # give each sample the approprate amount of dE
        trackSampleWeights = np.ones(trackSamplePoints.shape[0])*track['dE']/nSamples

        if not 'samplePoints' in dir():
            samplePoints = trackSamplePoints
            sampleWeights = trackSampleWeights
        else:
            samplePoints = np.concatenate([samplePoints,
                                           trackSamplePoints])
            sampleWeights = np.concatenate([sampleWeights,
                                            trackSampleWeights])

    ind = np.cast[int]((samplePoints - minVox)//spacing)

    # get the bin centers that correspond to each track sample
    binCenters = np.array([trackVoxelEdges[i][ind[:,i]] + 0.5*spacing[i]
                           for i in range(3)])

    # sum the energy in voxels that are occupied
    voxelContent = defaultdict(int)
    for coord, w in zip(binCenters.T, sampleWeights):
        voxelContent[tuple(coord)] += w

    return list(voxelContent.keys()), list(voxelContent.values())


voxel_dtype = np.dtype([("eventID", "u4"),
                        ("xBin", "f4"),
                        ("yBin", "f4"),
                        ("zBin", "f4"),
                        ("dE", "f4")],
                       align = True)

def main(args):    
    infile = h5py.File(args.infile, 'r')
    outfile = h5py.File(args.output, 'w')    
    
    for key in infile.keys():
        if key != "track_voxels":
            if type(infile[key]) == h5py.Dataset:
                outfile.create_dataset(key, data = infile[key])
            elif type(infile[key]) == h5py.Group:
                outfile.create_group(key)
                infile.copy(infile[key], outfile[key], key)
            
    outfile.create_dataset("track_voxels",
                           shape = (0,),
                           dtype = voxel_dtype,
                           maxshape = (None,))

    tracks = infile['tracks']

    for track_ev_id in tqdm.tqdm(np.unique(tracks['eventID'])):

        tracks_ev = tracks[tracks['eventID'] == track_ev_id]
            
        voxelizedEdep = vox.voxelize(tracks_ev)

        nVox = len(voxelizedEdep[1])
        evVoxels = np.empty(nVox, dtype = voxel_dtype)
        evVoxels['xBin'] = np.array([pos[0] for pos in voxelizedEdep[0]])
        evVoxels['yBin'] = np.array([pos[1] for pos in voxelizedEdep[0]])
        evVoxels['zBin'] = np.array([pos[2] for pos in voxelizedEdep[0]])
        evVoxels['dE'] = voxelizedEdep[1]
        evVoxels['eventID'] = track_ev_id*np.ones(nVox)

        nVoxPrev = len(outfile['track_voxels'])
        outfile['track_voxels'].resize((nVox+nVoxPrev,))
        outfile['track_voxels'][nVoxPrev:] = evVoxels
        
if __name__ == '__main__':

    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('infile', type = str,
                        help = "input hdf5 larpix file (from dumpTree.py)")
    parser.add_argument('-o', '--output', type = str,
                        required = True,
                        help = "output hdf5 file containing an additional database of voxelized edeps")

    args = parser.parse_args()

    main(args)
